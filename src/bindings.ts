
// This file was generated by [tauri-specta](https://github.com/oscartbeaumont/tauri-specta). Do not edit this file manually.

/** user-defined commands **/


export const commands = {
async changeBinding(id: string, binding: string) : Promise<Result<BindingResponse, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("change_binding", { id, binding }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async resetBinding(id: string) : Promise<Result<BindingResponse, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("reset_binding", { id }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async changePttSetting(enabled: boolean) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("change_ptt_setting", { enabled }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async changeAudioFeedbackSetting(enabled: boolean) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("change_audio_feedback_setting", { enabled }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async changeAudioFeedbackVolumeSetting(volume: number) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("change_audio_feedback_volume_setting", { volume }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async changeSoundThemeSetting(theme: string) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("change_sound_theme_setting", { theme }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async changeStartHiddenSetting(enabled: boolean) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("change_start_hidden_setting", { enabled }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async changeAutostartSetting(enabled: boolean) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("change_autostart_setting", { enabled }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async changeTranslateToEnglishSetting(enabled: boolean) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("change_translate_to_english_setting", { enabled }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async changeSelectedLanguageSetting(language: string) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("change_selected_language_setting", { language }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async changeOverlayPositionSetting(position: string) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("change_overlay_position_setting", { position }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async changeDebugModeSetting(enabled: boolean) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("change_debug_mode_setting", { enabled }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async changeWordCorrectionThresholdSetting(threshold: number) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("change_word_correction_threshold_setting", { threshold }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async changePasteMethodSetting(method: string) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("change_paste_method_setting", { method }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async changeClipboardHandlingSetting(handling: string) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("change_clipboard_handling_setting", { handling }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async changePostProcessEnabledSetting(enabled: boolean) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("change_post_process_enabled_setting", { enabled }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async changePostProcessBaseUrlSetting(providerId: string, baseUrl: string) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("change_post_process_base_url_setting", { providerId, baseUrl }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async changePostProcessApiKeySetting(providerId: string, apiKey: string) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("change_post_process_api_key_setting", { providerId, apiKey }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async changePostProcessModelSetting(providerId: string, model: string) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("change_post_process_model_setting", { providerId, model }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async setPostProcessProvider(providerId: string) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("set_post_process_provider", { providerId }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async fetchPostProcessModels(providerId: string) : Promise<Result<string[], string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("fetch_post_process_models", { providerId }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async addPostProcessPrompt(name: string, prompt: string) : Promise<Result<LLMPrompt, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("add_post_process_prompt", { name, prompt }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async updatePostProcessPrompt(id: string, name: string, prompt: string) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("update_post_process_prompt", { id, name, prompt }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async deletePostProcessPrompt(id: string) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("delete_post_process_prompt", { id }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async setPostProcessSelectedPrompt(id: string) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("set_post_process_selected_prompt", { id }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async updateCustomWords(words: string[]) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("update_custom_words", { words }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Temporarily unregister a binding while the user is editing it in the UI.
 * This avoids firing the action while keys are being recorded.
 */
async suspendBinding(id: string) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("suspend_binding", { id }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Re-register the binding after the user has finished editing.
 */
async resumeBinding(id: string) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("resume_binding", { id }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async changeMuteWhileRecordingSetting(enabled: boolean) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("change_mute_while_recording_setting", { enabled }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async changeAppendTrailingSpaceSetting(enabled: boolean) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("change_append_trailing_space_setting", { enabled }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async changeAppLanguageSetting(language: string) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("change_app_language_setting", { language }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async changeUpdateChecksSetting(enabled: boolean) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("change_update_checks_setting", { enabled }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async changeFillerDetectionSetting(enabled: boolean) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("change_filler_detection_setting", { enabled }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async changeFillerOutputModeSetting(mode: string) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("change_filler_output_mode_setting", { mode }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async updateCustomFillerWords(words: string[]) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("update_custom_filler_words", { words }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async changeShowFillerOverlaySetting(enabled: boolean) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("change_show_filler_overlay_setting", { enabled }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async setActiveUiSection(section: string) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("set_active_ui_section", { section }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async changeOnichanSilenceThresholdSetting(thresholdMs: number) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("change_onichan_silence_threshold_setting", { thresholdMs }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async triggerUpdateCheck() : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("trigger_update_check") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async cancelOperation() : Promise<void> {
    await TAURI_INVOKE("cancel_operation");
},
async getAppDirPath() : Promise<Result<string, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("get_app_dir_path") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async getAppSettings() : Promise<Result<AppSettings, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("get_app_settings") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async getDefaultSettings() : Promise<Result<AppSettings, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("get_default_settings") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async getLogDirPath() : Promise<Result<string, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("get_log_dir_path") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async setLogLevel(level: LogLevel) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("set_log_level", { level }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async openRecordingsFolder() : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("open_recordings_folder") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async openLogDir() : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("open_log_dir") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async openAppDataDir() : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("open_app_data_dir") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Check if Apple Intelligence is available on this device.
 * Called by the frontend when the user selects Apple Intelligence provider.
 */
async checkAppleIntelligenceAvailable() : Promise<boolean> {
    return await TAURI_INVOKE("check_apple_intelligence_available");
},
async getAvailableModels() : Promise<Result<ModelInfo[], string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("get_available_models") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async getModelInfo(modelId: string) : Promise<Result<ModelInfo | null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("get_model_info", { modelId }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async downloadModel(modelId: string) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("download_model", { modelId }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async deleteModel(modelId: string) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("delete_model", { modelId }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async cancelDownload(modelId: string) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("cancel_download", { modelId }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async setActiveModel(modelId: string) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("set_active_model", { modelId }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async getCurrentModel() : Promise<Result<string, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("get_current_model") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async getTranscriptionModelStatus() : Promise<Result<string | null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("get_transcription_model_status") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async isModelLoading() : Promise<Result<boolean, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("is_model_loading") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async hasAnyModelsAvailable() : Promise<Result<boolean, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("has_any_models_available") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async hasAnyModelsOrDownloads() : Promise<Result<boolean, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("has_any_models_or_downloads") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async getRecommendedFirstModel() : Promise<Result<string, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("get_recommended_first_model") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async updateMicrophoneMode(alwaysOn: boolean) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("update_microphone_mode", { alwaysOn }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async getMicrophoneMode() : Promise<Result<boolean, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("get_microphone_mode") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async getAvailableMicrophones() : Promise<Result<AudioDevice[], string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("get_available_microphones") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async setSelectedMicrophone(deviceName: string) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("set_selected_microphone", { deviceName }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async getSelectedMicrophone() : Promise<Result<string, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("get_selected_microphone") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async getAvailableOutputDevices() : Promise<Result<AudioDevice[], string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("get_available_output_devices") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async setSelectedOutputDevice(deviceName: string) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("set_selected_output_device", { deviceName }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async getSelectedOutputDevice() : Promise<Result<string, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("get_selected_output_device") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async playTestSound(soundType: string) : Promise<void> {
    await TAURI_INVOKE("play_test_sound", { soundType });
},
async checkCustomSounds() : Promise<CustomSounds> {
    return await TAURI_INVOKE("check_custom_sounds");
},
async setClamshellMicrophone(deviceName: string) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("set_clamshell_microphone", { deviceName }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async getClamshellMicrophone() : Promise<Result<string, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("get_clamshell_microphone") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async isRecording() : Promise<boolean> {
    return await TAURI_INVOKE("is_recording");
},
async setModelUnloadTimeout(timeout: ModelUnloadTimeout) : Promise<void> {
    await TAURI_INVOKE("set_model_unload_timeout", { timeout });
},
async getModelLoadStatus() : Promise<Result<ModelLoadStatus, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("get_model_load_status") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async unloadModelManually() : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("unload_model_manually") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async getHistoryEntries() : Promise<Result<HistoryEntry[], string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("get_history_entries") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async toggleHistoryEntrySaved(id: number) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("toggle_history_entry_saved", { id }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async getAudioFilePath(fileName: string) : Promise<Result<string, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("get_audio_file_path", { fileName }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async deleteHistoryEntry(id: number) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("delete_history_entry", { id }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async updateHistoryLimit(limit: number) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("update_history_limit", { limit }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async updateRecordingRetentionPeriod(period: string) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("update_recording_retention_period", { period }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Reset the app to a fresh state by deleting all data, models, and settings.
 * After this command, the app should be restarted to complete the reset.
 */
async resetAppData() : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("reset_app_data") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async onichanEnable() : Promise<void> {
    await TAURI_INVOKE("onichan_enable");
},
async onichanDisable() : Promise<void> {
    await TAURI_INVOKE("onichan_disable");
},
async onichanIsActive() : Promise<boolean> {
    return await TAURI_INVOKE("onichan_is_active");
},
async onichanGetMode() : Promise<OnichanMode> {
    return await TAURI_INVOKE("onichan_get_mode");
},
async onichanSetMode(mode: OnichanMode) : Promise<void> {
    await TAURI_INVOKE("onichan_set_mode", { mode });
},
async onichanProcessInput(text: string) : Promise<Result<string, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("onichan_process_input", { text }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async onichanSpeak(text: string) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("onichan_speak", { text }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async onichanClearHistory() : Promise<void> {
    await TAURI_INVOKE("onichan_clear_history");
},
async onichanGetHistory() : Promise<ConversationMessage[]> {
    return await TAURI_INVOKE("onichan_get_history");
},
async getOnichanModels() : Promise<OnichanModelInfo[]> {
    return await TAURI_INVOKE("get_onichan_models");
},
async getOnichanLlmModels() : Promise<OnichanModelInfo[]> {
    return await TAURI_INVOKE("get_onichan_llm_models");
},
async getOnichanTtsModels() : Promise<OnichanModelInfo[]> {
    return await TAURI_INVOKE("get_onichan_tts_models");
},
async downloadOnichanModel(modelId: string) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("download_onichan_model", { modelId }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async deleteOnichanModel(modelId: string) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("delete_onichan_model", { modelId }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async loadLocalLlm(modelId: string) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("load_local_llm", { modelId }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async unloadLocalLlm() : Promise<void> {
    await TAURI_INVOKE("unload_local_llm");
},
async isLocalLlmLoaded() : Promise<boolean> {
    return await TAURI_INVOKE("is_local_llm_loaded");
},
async getLocalLlmModelName() : Promise<string | null> {
    return await TAURI_INVOKE("get_local_llm_model_name");
},
async localLlmChat(systemPrompt: string, userMessage: string, maxTokens: number) : Promise<Result<string, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("local_llm_chat", { systemPrompt, userMessage, maxTokens }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async loadLocalTts(modelId: string) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("load_local_tts", { modelId }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async unloadLocalTts() : Promise<void> {
    await TAURI_INVOKE("unload_local_tts");
},
async isLocalTtsLoaded() : Promise<boolean> {
    return await TAURI_INVOKE("is_local_tts_loaded");
},
async localTtsSpeak(text: string) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("local_tts_speak", { text }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async onichanStartConversation() : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("onichan_start_conversation") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async onichanStopConversation() : Promise<void> {
    await TAURI_INVOKE("onichan_stop_conversation");
},
async onichanIsConversationRunning() : Promise<boolean> {
    return await TAURI_INVOKE("onichan_is_conversation_running");
},
/**
 * Check if a Discord bot token is configured (without returning the actual token)
 */
async discordHasToken() : Promise<boolean> {
    return await TAURI_INVOKE("discord_has_token");
},
/**
 * Get a masked version of the Discord bot token for display purposes only
 * Returns None if no token is set, or a masked string like "********...abcd"
 */
async discordGetToken() : Promise<string | null> {
    return await TAURI_INVOKE("discord_get_token");
},
/**
 * Set the Discord bot token (stores securely, never echoed back in full)
 */
async discordSetToken(token: string) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("discord_set_token", { token }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Clear the stored Discord bot token
 */
async discordClearToken() : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("discord_clear_token") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Connect to Discord using the stored token
 */
async discordConnectWithStoredToken() : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("discord_connect_with_stored_token") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Get Discord connection status
 */
async discordGetStatus() : Promise<DiscordState> {
    return await TAURI_INVOKE("discord_get_status");
},
/**
 * Get list of guilds the bot is in
 */
async discordGetGuilds() : Promise<Result<GuildInfo[], string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("discord_get_guilds") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Get voice channels for a guild
 */
async discordGetChannels(guildId: string) : Promise<Result<ChannelInfo[], string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("discord_get_channels", { guildId }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Connect to a Discord voice channel
 */
async discordConnect(guildId: string, channelId: string) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("discord_connect", { guildId, channelId }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Disconnect from Discord voice
 */
async discordDisconnect() : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("discord_disconnect") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Speak text in the voice channel
 */
async discordSpeak(text: string) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("discord_speak", { text }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Start Discord conversation mode (listen and respond to voice in Discord)
 */
async discordStartConversation() : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("discord_start_conversation") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Stop Discord conversation mode
 */
async discordStopConversation() : Promise<void> {
    await TAURI_INVOKE("discord_stop_conversation");
},
/**
 * Check if Discord conversation mode is running
 */
async discordIsConversationRunning() : Promise<boolean> {
    return await TAURI_INVOKE("discord_is_conversation_running");
},
/**
 * Get the Supabase URL (returns default if not set)
 */
async getSupabaseUrl() : Promise<string> {
    return await TAURI_INVOKE("get_supabase_url");
},
/**
 * Set the Supabase URL
 */
async setSupabaseUrl(url: string) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("set_supabase_url", { url }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Get a masked version of the Supabase anon key for display (returns masked default if not set)
 */
async getSupabaseAnonKey() : Promise<string> {
    return await TAURI_INVOKE("get_supabase_anon_key");
},
/**
 * Get the actual Supabase anon key (for internal use by auth system)
 * This returns the unmasked key - use with care
 */
async getSupabaseAnonKeyRaw() : Promise<string> {
    return await TAURI_INVOKE("get_supabase_anon_key_raw");
},
/**
 * Check if Supabase anon key is configured (always true since we have a default)
 */
async hasSupabaseAnonKey() : Promise<boolean> {
    return await TAURI_INVOKE("has_supabase_anon_key");
},
/**
 * Set the Supabase anon key (stored securely, only masked version returned)
 */
async setSupabaseAnonKey(key: string) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("set_supabase_anon_key", { key }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Clear Supabase credentials
 */
async clearSupabaseCredentials() : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("clear_supabase_credentials") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Start the OAuth callback server and return the callback URL
 * Call this before opening the OAuth URL in the browser
 */
async authStartServer() : Promise<Result<string, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("auth_start_server") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Stop the OAuth callback server (called after auth completes or on cancel)
 */
async authStopServer() : Promise<void> {
    await TAURI_INVOKE("auth_stop_server");
},
/**
 * Save Supabase session to secure credentials store
 */
async authSaveSession(session: SupabaseSession) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("auth_save_session", { session }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Load Supabase session from credentials store
 */
async authGetSession() : Promise<SupabaseSession | null> {
    return await TAURI_INVOKE("auth_get_session");
},
/**
 * Get current authenticated user info (safe to expose)
 */
async authGetUser() : Promise<AuthUser> {
    return await TAURI_INVOKE("auth_get_user");
},
/**
 * Clear auth session (logout)
 */
async authLogout() : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("auth_logout") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Check if user is authenticated
 */
async authIsAuthenticated() : Promise<boolean> {
    return await TAURI_INVOKE("auth_is_authenticated");
},
/**
 * Get the access token for API requests
 * Returns None if not authenticated or token is expired
 */
async authGetAccessToken() : Promise<string | null> {
    return await TAURI_INVOKE("auth_get_access_token");
},
/**
 * Get the current status of the memory system
 */
async getMemoryStatus() : Promise<Result<MemoryStatus, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("get_memory_status") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Query memories semantically (for all users)
 */
async queryAllMemories(query: string, limit: number) : Promise<Result<MemoryMessage[], string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("query_all_memories", { query, limit }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Get total count of all memories
 * Note: Returns 0 if sidecar is not running to avoid spawning it just to check count
 */
async getMemoryCount() : Promise<Result<number, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("get_memory_count") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Clear all memories
 */
async clearAllMemories() : Promise<Result<number, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("clear_all_memories") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Cleanup old memories based on TTL
 */
async cleanupOldMemories(ttlDays: number) : Promise<Result<number, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("cleanup_old_memories", { ttlDays }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * List available embedding models
 */
async listEmbeddingModels() : Promise<Result<EmbeddingModelInfo[], string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("list_embedding_models") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Load an embedding model by ID
 */
async loadEmbeddingModel(modelId: string) : Promise<Result<string, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("load_embedding_model", { modelId }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Get the currently loaded embedding model
 */
async getCurrentEmbeddingModel() : Promise<Result<EmbeddingModelInfo | null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("get_current_embedding_model") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Stop the memory sidecar
 */
async stopMemorySidecar() : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("stop_memory_sidecar") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Browse recent memories without semantic search
 * Supports filtering by user_id and is_bot
 */
async browseRecentMemories(limit: number, userId: string | null, isBot: boolean | null) : Promise<Result<MemoryMessage[], string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("browse_recent_memories", { limit, userId, isBot }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * List unique users with memory counts
 */
async listMemoryUsers() : Promise<Result<MemoryUserInfo[], string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("list_memory_users") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Check if required DevOps dependencies (gh, tmux) are installed.
 * Runs in a blocking task to avoid freezing the UI.
 */
async checkDevopsDependencies() : Promise<Result<DevOpsDependencies, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("check_devops_dependencies") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Launch authentication flow for a CLI tool by creating a tmux session.
 * Returns the session name so the user can attach to it.
 */
async launchCliAuth(toolName: string) : Promise<Result<string, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("launch_cli_auth", { toolName }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Attach to an existing tmux session by opening Terminal.app.
 */
async attachTmuxSession(sessionName: string) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("attach_tmux_session", { sessionName }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * List all Handy agent tmux sessions.
 */
async listTmuxSessions() : Promise<Result<TmuxSession[], string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("list_tmux_sessions") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Get metadata for a specific tmux session.
 */
async getTmuxSessionMetadata(sessionName: string) : Promise<Result<AgentMetadata, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("get_tmux_session_metadata", { sessionName }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Create a new tmux session with metadata.
 */
async createTmuxSession(sessionName: string, workingDir: string | null, issueRef: string | null, repo: string | null, agentType: string) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("create_tmux_session", { sessionName, workingDir, issueRef, repo, agentType }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Kill a tmux session.
 */
async killTmuxSession(sessionName: string) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("kill_tmux_session", { sessionName }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Get recent output from a tmux session.
 */
async getTmuxSessionOutput(sessionName: string, lines: number | null) : Promise<Result<string, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("get_tmux_session_output", { sessionName, lines }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Send a command to a tmux session (appends Enter key).
 * If command is empty, sends just Enter key.
 */
async sendTmuxCommand(sessionName: string, command: string) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("send_tmux_command", { sessionName, command }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Send raw keys to a tmux session without appending Enter.
 * Use for special keys: Enter, Escape, Tab, Space, BSpace, Up, Down, Left, Right, C-c, etc.
 */
async sendTmuxKeys(sessionName: string, keys: string) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("send_tmux_keys", { sessionName, keys }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Recover agent sessions on startup.
 */
async recoverTmuxSessions() : Promise<Result<RecoveredSession[], string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("recover_tmux_sessions") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Restart an agent in an existing tmux session.
 * 
 * Use this for recovery when a session exists but the agent process has stopped.
 * This reads the session metadata and restarts the appropriate agent command.
 */
async restartAgentInSession(sessionName: string) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("restart_agent_in_session", { sessionName }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Recover all sessions that need attention.
 * 
 * - `auto_restart`: If true, automatically restart agents in stopped sessions
 * - `auto_cleanup`: If true, automatically kill orphaned sessions (no worktree)
 * 
 * Returns results for each session that was processed.
 */
async recoverAllAgentSessions(autoRestart: boolean, autoCleanup: boolean) : Promise<Result<RecoveryResult[], string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("recover_all_agent_sessions", { autoRestart, autoCleanup }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Check if tmux server is running.
 */
async isTmuxRunning() : Promise<boolean> {
    return await TAURI_INVOKE("is_tmux_running");
},
/**
 * Ensure a master tmux session exists for orchestration.
 * Returns true if the session was created, false if it already exists.
 */
async ensureMasterTmuxSession() : Promise<Result<boolean, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("ensure_master_tmux_session") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * List all git worktrees in a repository.
 */
async listGitWorktrees(repoPath: string) : Promise<Result<WorktreeInfo[], string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("list_git_worktrees", { repoPath }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Get information about a specific worktree.
 */
async getGitWorktreeInfo(repoPath: string, worktreePath: string) : Promise<Result<WorktreeInfo, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("get_git_worktree_info", { repoPath, worktreePath }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Check for collisions before creating a worktree.
 */
async checkWorktreeCollision(repoPath: string, worktreePath: string, branchName: string) : Promise<Result<CollisionCheck, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("check_worktree_collision", { repoPath, worktreePath, branchName }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Create a new git worktree with a new branch.
 */
async createGitWorktree(repoPath: string, name: string, prefix: string | null, basePath: string | null, baseBranch: string | null) : Promise<Result<WorktreeCreateResult, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("create_git_worktree", { repoPath, name, prefix, basePath, baseBranch }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Create a worktree using an existing branch.
 */
async createGitWorktreeExistingBranch(repoPath: string, branchName: string, prefix: string | null, basePath: string | null) : Promise<Result<WorktreeCreateResult, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("create_git_worktree_existing_branch", { repoPath, branchName, prefix, basePath }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Remove a git worktree.
 */
async removeGitWorktree(repoPath: string, worktreePath: string, force: boolean, deleteBranch: boolean) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("remove_git_worktree", { repoPath, worktreePath, force, deleteBranch }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Prune stale worktree entries.
 */
async pruneGitWorktrees(repoPath: string) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("prune_git_worktrees", { repoPath }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Get the root directory of a git repository.
 */
async getGitRepoRoot(path: string) : Promise<Result<string, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("get_git_repo_root", { path }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Get the default branch of a repository.
 */
async getGitDefaultBranch(repoPath: string) : Promise<Result<string, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("get_git_default_branch", { repoPath }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Suggest local paths for a GitHub repository.
 * Searches common locations for cloned repos matching the given owner/repo format.
 */
async suggestLocalRepoPath(githubRepo: string) : Promise<string[]> {
    return await TAURI_INVOKE("suggest_local_repo_path", { githubRepo });
},
/**
 * Check GitHub CLI authentication status.
 */
async checkGhAuth() : Promise<GhAuthStatus> {
    return await TAURI_INVOKE("check_gh_auth");
},
/**
 * List issues from a GitHub repository.
 */
async listGithubIssues(repo: string, state: string | null, labels: string[] | null, limit: number | null) : Promise<Result<GitHubIssue[], string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("list_github_issues", { repo, state, labels, limit }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Get details of a specific GitHub issue.
 */
async getGithubIssue(repo: string, number: number) : Promise<Result<GitHubIssue, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("get_github_issue", { repo, number }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Get issue with agent metadata.
 */
async getGithubIssueWithAgent(repo: string, number: number) : Promise<Result<IssueWithAgent, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("get_github_issue_with_agent", { repo, number }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Create a new GitHub issue.
 */
async createGithubIssue(repo: string, title: string, body: string | null, labels: string[] | null) : Promise<Result<GitHubIssue, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("create_github_issue", { repo, title, body, labels }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Add a comment to a GitHub issue.
 */
async commentOnGithubIssue(repo: string, number: number, body: string) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("comment_on_github_issue", { repo, number, body }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Assign an agent to a GitHub issue (adds metadata comment).
 */
async assignAgentToIssue(repo: string, number: number, session: string, agentType: string, worktree: string | null) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("assign_agent_to_issue", { repo, number, session, agentType, worktree }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * List comments on a GitHub issue.
 */
async listGithubIssueComments(repo: string, number: number) : Promise<Result<GitHubComment[], string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("list_github_issue_comments", { repo, number }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Update labels on a GitHub issue.
 */
async updateGithubIssueLabels(repo: string, number: number, addLabels: string[], removeLabels: string[]) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("update_github_issue_labels", { repo, number, addLabels, removeLabels }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Close a GitHub issue.
 */
async closeGithubIssue(repo: string, number: number, comment: string | null) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("close_github_issue", { repo, number, comment }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Reopen a closed GitHub issue.
 */
async reopenGithubIssue(repo: string, number: number) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("reopen_github_issue", { repo, number }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * List pull requests from a GitHub repository.
 */
async listGithubPrs(repo: string, state: string | null, base: string | null, limit: number | null) : Promise<Result<GitHubPullRequest[], string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("list_github_prs", { repo, state, base, limit }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Get details of a specific GitHub pull request.
 */
async getGithubPr(repo: string, number: number) : Promise<Result<GitHubPullRequest, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("get_github_pr", { repo, number }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Get full status of a pull request (PR + checks + reviews).
 */
async getGithubPrStatus(repo: string, number: number) : Promise<Result<PrStatus, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("get_github_pr_status", { repo, number }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Create a new GitHub pull request.
 */
async createGithubPr(repo: string, title: string, body: string | null, base: string, head: string | null, draft: boolean) : Promise<Result<GitHubPullRequest, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("create_github_pr", { repo, title, body, base, head, draft }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Merge a GitHub pull request.
 */
async mergeGithubPr(repo: string, number: number, method: string | null, deleteBranch: boolean) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("merge_github_pr", { repo, number, method, deleteBranch }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Close a GitHub pull request without merging.
 */
async closeGithubPr(repo: string, number: number, comment: string | null) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("close_github_pr", { repo, number, comment }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Spawn a new agent to work on an issue.
 * 
 * Creates a worktree, tmux session, and updates the issue with metadata.
 */
async spawnAgent(repo: string, issueNumber: number, agentType: string, repoPath: string, sessionName: string | null, worktreePrefix: string | null, workingLabels: string[] | null) : Promise<Result<SpawnResult, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("spawn_agent", { repo, issueNumber, agentType, repoPath, sessionName, worktreePrefix, workingLabels }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Get status of all active agents.
 */
async listAgentStatuses() : Promise<Result<AgentStatus[], string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("list_agent_statuses") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Clean up an agent's resources after work is complete.
 */
async cleanupAgent(sessionName: string, repoPath: string, removeWorktree: boolean, deleteBranch: boolean) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("cleanup_agent", { sessionName, repoPath, removeWorktree, deleteBranch }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Create a PR from an agent's work.
 */
async createPrFromAgent(sessionName: string, title: string, body: string | null, draft: boolean) : Promise<Result<GitHubPullRequest, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("create_pr_from_agent", { sessionName, title, body, draft }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Complete an agent's work with workflow automation.
 * 
 * Creates PR, updates issue with link, manages labels.
 */
async completeAgentWork(sessionName: string, prTitle: string, prBody: string | null, workingLabels: string[], prLabels: string[], draftPr: boolean) : Promise<Result<CompleteWorkResult, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("complete_agent_work", { sessionName, prTitle, prBody, workingLabels, prLabels, draftPr }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Check if a PR has been merged and cleanup resources if so.
 */
async checkAndCleanupMergedPr(sessionName: string, repoPath: string, prNumber: number) : Promise<Result<boolean, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("check_and_cleanup_merged_pr", { sessionName, repoPath, prNumber }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Get current machine identifier.
 */
async getCurrentMachineId() : Promise<string> {
    return await TAURI_INVOKE("get_current_machine_id");
},
/**
 * List only agents running on this machine.
 */
async listLocalAgentStatuses() : Promise<Result<AgentStatus[], string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("list_local_agent_statuses") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * List agents from other machines (potentially orphaned).
 */
async listRemoteAgentStatuses() : Promise<Result<AgentStatus[], string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("list_remote_agent_statuses") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Toggle an agent type on/off.
 */
async toggleAgentEnabled(agentType: string, enabled: boolean) : Promise<Result<string[], string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("toggle_agent_enabled", { agentType, enabled }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Get list of enabled agents.
 */
async getEnabledAgents() : Promise<string[]> {
    return await TAURI_INVOKE("get_enabled_agents");
},
/**
 * Set the list of enabled agents (bulk update).
 */
async setEnabledAgents(agents: string[]) : Promise<string[]> {
    return await TAURI_INVOKE("set_enabled_agents", { agents });
},
/**
 * Get whether sandbox mode is enabled for agent spawning.
 */
async getSandboxEnabled() : Promise<boolean> {
    return await TAURI_INVOKE("get_sandbox_enabled");
},
/**
 * Set whether sandbox mode is enabled for agent spawning.
 */
async setSandboxEnabled(enabled: boolean) : Promise<boolean> {
    return await TAURI_INVOKE("set_sandbox_enabled", { enabled });
},
/**
 * Create a new epic issue with standardized structure
 */
async createEpic(config: EpicConfig) : Promise<Result<EpicInfo, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("create_epic", { config }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Create multiple sub-issues for an epic in batch
 */
async createSubIssues(epicNumber: number, epicRepo: string, epicWorkRepo: string, subIssues: SubIssueConfig[]) : Promise<Result<SubIssueInfo[], string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("create_sub_issues", { epicNumber, epicRepo, epicWorkRepo, subIssues }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Update epic issue progress based on sub-issue completion
 */
async updateEpicProgress(epicNumber: number, epicRepo: string) : Promise<Result<EpicProgress, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("update_epic_progress", { epicNumber, epicRepo }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Spawn an agent for a GitHub issue
 */
async spawnAgentFromIssue(config: SpawnAgentConfig) : Promise<Result<AgentSpawnResult, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("spawn_agent_from_issue", { config }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Complete agent work by creating a PR
 */
async completeAgentWorkWithPr(session: string, prTitle: string | null) : Promise<Result<AgentCompletionResult, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("complete_agent_work_with_pr", { session, prTitle }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Plan an Epic from a markdown file using AI agent
 */
async planEpicFromMarkdown(config: PlanFromMarkdownConfig) : Promise<Result<PlanResult, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("plan_epic_from_markdown", { config }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * List all available Epic plan templates from docs/plans directory
 */
async listEpicPlanTemplates() : Promise<Result<PlanTemplate[], string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("list_epic_plan_templates") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Start orchestration for an epic - creates sub-issues and optionally spawns agents
 */
async startEpicOrchestration(epic: EpicInfo, config: StartOrchestrationConfig) : Promise<Result<OrchestrationResult, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("start_epic_orchestration", { epic, config }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Get status of all phases in an epic
 */
async getEpicPhaseStatus(epicNumber: number, epicRepo: string, phases: PhaseConfig[]) : Promise<Result<PhaseStatus[], string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("get_epic_phase_status", { epicNumber, epicRepo, phases }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Load an existing epic from GitHub by issue number
 * 
 * Parses the epic's body to extract phases and metadata for orchestration.
 */
async loadEpic(repo: string, epicNumber: number) : Promise<Result<EpicInfo, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("load_epic", { repo, epicNumber }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Load an existing epic with full recovery information
 * 
 * Fetches the epic, all its sub-issues, and determines what work remains.
 * Useful for recovering/continuing orchestration on an existing epic.
 */
async loadEpicForRecovery(repo: string, epicNumber: number) : Promise<Result<EpicRecoveryInfo, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("load_epic_for_recovery", { repo, epicNumber }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Get the currently active Epic state (persisted across app restarts).
 */
async getActiveEpicState() : Promise<ActiveEpicState | null> {
    return await TAURI_INVOKE("get_active_epic_state");
},
/**
 * Set the active Epic from an EpicInfo (when linking an Epic).
 */
async setActiveEpicState(epicInfo: EpicInfo) : Promise<ActiveEpicState> {
    return await TAURI_INVOKE("set_active_epic_state", { epicInfo });
},
/**
 * Set the active Epic from recovery info (more complete data with sub-issues).
 */
async setActiveEpicFromRecovery(recovery: EpicRecoveryInfo) : Promise<ActiveEpicState> {
    return await TAURI_INVOKE("set_active_epic_from_recovery", { recovery });
},
/**
 * Clear the active Epic state. If archive is true, moves to history.
 */
async clearActiveEpicState(archive: boolean) : Promise<ActiveEpicState | null> {
    return await TAURI_INVOKE("clear_active_epic_state", { archive });
},
/**
 * Sync the active Epic state with GitHub to get latest sub-issue status.
 */
async syncActiveEpicState() : Promise<Result<ActiveEpicState | null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("sync_active_epic_state") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Update a sub-issue's agent assignment in the active Epic.
 */
async updateEpicSubIssueAgent(issueNumber: number, sessionName: string | null, agentType: string | null) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("update_epic_sub_issue_agent", { issueNumber, sessionName, agentType }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Check if Docker is available and daemon is running
 */
async isDockerAvailable() : Promise<boolean> {
    return await TAURI_INVOKE("is_docker_available");
},
/**
 * Spawn a sandboxed agent in a Docker container
 * 
 * This creates an isolated container where the agent can run with
 * auto-accept permissions safely. The container has:
 * - The worktree mounted at /workspace
 * - GitHub and Anthropic credentials passed as env vars
 * - Resource limits applied
 */
async spawnSandbox(config: SandboxConfig) : Promise<Result<SandboxResult, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("spawn_sandbox", { config }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Get status of a sandbox container
 */
async getSandboxStatus(containerName: string) : Promise<Result<SandboxStatus, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("get_sandbox_status", { containerName }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Get logs from a sandbox container
 */
async getSandboxLogs(containerName: string, tail: number | null) : Promise<Result<string, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("get_sandbox_logs", { containerName, tail }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Stop a sandbox container
 */
async stopSandbox(containerName: string) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("stop_sandbox", { containerName }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Remove a sandbox container
 */
async removeSandbox(containerName: string, force: boolean) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("remove_sandbox", { containerName, force }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * List all Handy sandbox containers
 */
async listSandboxes() : Promise<Result<SandboxStatus[], string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("list_sandboxes") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Check if devcontainer CLI is available
 */
async isDevcontainerCliAvailable() : Promise<boolean> {
    return await TAURI_INVOKE("is_devcontainer_cli_available");
},
/**
 * Setup a devcontainer configuration for a worktree
 * 
 * Creates a .devcontainer/devcontainer.json file with the official
 * Anthropic Claude Code feature configured.
 */
async setupDevcontainer(worktreePath: string, issueRef: string, ghToken: string | null, anthropicKey: string | null) : Promise<Result<string, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("setup_devcontainer", { worktreePath, issueRef, ghToken, anthropicKey }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Start a devcontainer for a workspace
 * 
 * Uses the devcontainer CLI to build and start the container.
 */
async startDevcontainer(worktreePath: string) : Promise<Result<string, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("start_devcontainer", { worktreePath }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Execute a command inside a running devcontainer
 */
async execInDevcontainer(worktreePath: string, command: string) : Promise<Result<string, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("exec_in_devcontainer", { worktreePath, command }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Assign an issue to an agent, creating worktree and tmux session.
 */
async assignIssueToAgentPipeline(config: AssignIssueConfig) : Promise<Result<AssignIssueResult, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("assign_issue_to_agent_pipeline", { config }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Skip an issue and update its labels.
 */
async skipIssue(config: SkipIssueConfig) : Promise<Result<PipelineItem, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("skip_issue", { config }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * List all pipeline items, aggregating from multiple sources.
 */
async listPipelineItems(workRepo: string | null) : Promise<Result<PipelineItem[], string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("list_pipeline_items", { workRepo }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Get pipeline history (completed items).
 */
async getPipelineHistory(limit: number | null) : Promise<PipelineItem[]> {
    return await TAURI_INVOKE("get_pipeline_history", { limit });
},
/**
 * Get pipeline summary statistics.
 */
async getPipelineSummary() : Promise<PipelineSummary> {
    return await TAURI_INVOKE("get_pipeline_summary");
},
/**
 * Detect and link PRs to pipeline items.
 */
async detectAndLinkPrs(workRepo: string) : Promise<Result<PipelineItem[], string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("detect_and_link_prs", { workRepo }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Sync PR status for all pipeline items with PRs.
 */
async syncAllPrStatuses() : Promise<Result<PipelineItem[], string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("sync_all_pr_statuses") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Update a specific pipeline item's PR status.
 */
async updatePipelineItemPrStatus(itemId: string) : Promise<Result<PipelineItem | null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("update_pipeline_item_pr_status", { itemId }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Get a pipeline item by ID.
 */
async getPipelineItem(itemId: string) : Promise<PipelineItem | null> {
    return await TAURI_INVOKE("get_pipeline_item", { itemId });
},
/**
 * Find a pipeline item by issue.
 */
async findPipelineItemByIssue(repo: string, issueNumber: number) : Promise<PipelineItem | null> {
    return await TAURI_INVOKE("find_pipeline_item_by_issue", { repo, issueNumber });
},
/**
 * Find a pipeline item by session name.
 */
async findPipelineItemBySession(sessionName: string) : Promise<PipelineItem | null> {
    return await TAURI_INVOKE("find_pipeline_item_by_session", { sessionName });
},
/**
 * Link a PR to a pipeline item.
 */
async linkPrToPipelineItem(itemId: string, prNumber: number, workRepo: string) : Promise<Result<PipelineItem, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("link_pr_to_pipeline_item", { itemId, prNumber, workRepo }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Archive a completed pipeline item.
 */
async archivePipelineItem(itemId: string) : Promise<Result<PipelineItem | null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("archive_pipeline_item", { itemId }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Remove a pipeline item (for cleanup).
 */
async removePipelineItem(itemId: string) : Promise<Result<PipelineItem | null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("remove_pipeline_item", { itemId }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Checks if the Mac is a laptop by detecting battery presence
 * 
 * This uses pmset to check for battery information.
 * Returns true if a battery is detected (laptop), false otherwise (desktop)
 */
async isLaptop() : Promise<Result<boolean, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("is_laptop") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Tauri command to check if VAD model is available
 */
async isVadModelReady() : Promise<boolean> {
    return await TAURI_INVOKE("is_vad_model_ready");
},
/**
 * Tauri command to download VAD model if needed
 */
async downloadVadModelIfNeeded() : Promise<Result<string, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("download_vad_model_if_needed") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
}
}

/** user-defined events **/



/** user-defined constants **/



/** user-defined types **/

/**
 * Persisted state for an active Epic workflow
 */
export type ActiveEpicState = { 
/**
 * Epic issue number
 */
epic_number: number; 
/**
 * Tracking repository (where Epic issue lives)
 */
tracking_repo: string; 
/**
 * Work repository (where code is written)
 */
work_repo: string; 
/**
 * Epic title
 */
title: string; 
/**
 * Epic URL
 */
url: string; 
/**
 * Phases with their tracked state
 */
phases: TrackedPhase[]; 
/**
 * All sub-issues for this epic
 */
sub_issues: TrackedSubIssue[]; 
/**
 * When this Epic was linked/loaded
 */
linked_at: string; 
/**
 * Last time state was synced with GitHub
 */
last_synced_at: string | null }
/**
 * Result of completing agent work
 */
export type AgentCompletionResult = { 
/**
 * PR URL
 */
pr_url: string; 
/**
 * Issue number
 */
issue_number: number; 
/**
 * Session name
 */
session: string; 
/**
 * Status
 */
status: string }
/**
 * Metadata stored with each agent session
 */
export type AgentMetadata = { 
/**
 * Session name (e.g., "handy-agent-42")
 */
session: string; 
/**
 * GitHub issue reference (e.g., "org/repo#42")
 */
issue_ref: string | null; 
/**
 * Repository being worked on
 */
repo: string | null; 
/**
 * Path to the worktree
 */
worktree: string | null; 
/**
 * Type of agent (e.g., "claude", "aider")
 */
agent_type: string; 
/**
 * Machine identifier for multi-machine disambiguation
 */
machine_id: string; 
/**
 * ISO timestamp when session started
 */
started_at: string }
/**
 * Result of spawning an agent
 */
export type AgentSpawnResult = { 
/**
 * tmux session name
 */
session: string; 
/**
 * Issue number
 */
issue_number: number; 
/**
 * Worktree path
 */
worktree: string; 
/**
 * Agent type used
 */
agent_type: string; 
/**
 * Agent metadata
 */
metadata: AgentMetadata }
/**
 * Status of an active agent.
 */
export type AgentStatus = { 
/**
 * Session name
 */
session: string; 
/**
 * Issue reference (owner/repo#number)
 */
issue_ref: string | null; 
/**
 * Repository
 */
repo: string | null; 
/**
 * Issue number
 */
issue_number: number | null; 
/**
 * Worktree path
 */
worktree: string | null; 
/**
 * Agent type
 */
agent_type: string; 
/**
 * Machine ID
 */
machine_id: string; 
/**
 * Started timestamp
 */
started_at: string; 
/**
 * Whether session is attached
 */
is_attached: boolean; 
/**
 * Whether this agent is on the current machine
 */
is_local: boolean }
export type AppSettings = { bindings: Partial<{ [key in string]: ShortcutBinding }>; push_to_talk: boolean; audio_feedback: boolean; audio_feedback_volume?: number; sound_theme?: SoundTheme; start_hidden?: boolean; autostart_enabled?: boolean; update_checks_enabled?: boolean; selected_model?: string; always_on_microphone?: boolean; selected_microphone?: string | null; clamshell_microphone?: string | null; selected_output_device?: string | null; translate_to_english?: boolean; selected_language?: string; overlay_position?: OverlayPosition; debug_mode?: boolean; log_level?: LogLevel; custom_words?: string[]; model_unload_timeout?: ModelUnloadTimeout; word_correction_threshold?: number; history_limit?: number; recording_retention_period?: RecordingRetentionPeriod; paste_method?: PasteMethod; clipboard_handling?: ClipboardHandling; post_process_enabled?: boolean; post_process_provider_id?: string; post_process_providers?: PostProcessProvider[]; post_process_api_keys?: Partial<{ [key in string]: string }>; post_process_models?: Partial<{ [key in string]: string }>; post_process_prompts?: LLMPrompt[]; post_process_selected_prompt_id?: string | null; mute_while_recording?: boolean; append_trailing_space?: boolean; app_language?: string; filler_detection_enabled?: boolean; filler_output_mode?: FillerOutputMode; custom_filler_words?: string[]; show_filler_overlay?: boolean; active_ui_section?: string; onichan_silence_threshold?: number; enabled_agents?: string[]; sandbox_enabled?: boolean }
/**
 * Configuration for assigning an issue to an agent.
 */
export type AssignIssueConfig = { 
/**
 * Repository where the issue exists (tracking repo)
 */
tracking_repo: string; 
/**
 * Repository where work will be done
 */
work_repo: string; 
/**
 * Issue number to assign
 */
issue_number: number; 
/**
 * Agent type to use
 */
agent_type: string; 
/**
 * Local path to the work repository
 */
repo_path: string; 
/**
 * Labels to add when work starts
 */
start_labels?: string[]; 
/**
 * Labels to remove when work starts
 */
remove_labels?: string[] }
/**
 * Result of assigning an issue to an agent.
 */
export type AssignIssueResult = { 
/**
 * The pipeline item created
 */
pipeline_item: PipelineItem; 
/**
 * The spawn result from orchestrator
 */
spawn_result: SpawnResult }
export type AudioDevice = { index: string; name: string; is_default: boolean }
export type AuthUser = { id: string; email: string | null; name: string | null; avatar_url: string | null; provider: string | null; is_authenticated: boolean }
export type BindingResponse = { success: boolean; binding: ShortcutBinding | null; error: string | null }
export type ChannelInfo = { id: string; name: string; kind: string }
export type ClipboardHandling = "dont_modify" | "copy_to_clipboard"
/**
 * Collision check result.
 */
export type CollisionCheck = { 
/**
 * Whether any collision was detected
 */
has_collision: boolean; 
/**
 * Path collision: directory already exists
 */
path_exists: boolean; 
/**
 * Branch collision: branch already exists
 */
branch_exists: boolean; 
/**
 * Worktree collision: worktree at path already exists
 */
worktree_exists: boolean; 
/**
 * Details about the collision
 */
details: string | null }
/**
 * Result of completing agent work.
 */
export type CompleteWorkResult = { 
/**
 * The created pull request
 */
pull_request: GitHubPullRequest; 
/**
 * Whether the issue was updated with PR link
 */
issue_updated: boolean; 
/**
 * Whether working labels were removed
 */
labels_updated: boolean }
/**
 * Message in the conversation
 */
export type ConversationMessage = { role: string; content: string }
export type CustomSounds = { start: boolean; stop: boolean }
/**
 * Status of a single dependency
 */
export type DependencyStatus = { 
/**
 * Name of the dependency
 */
name: string; 
/**
 * Whether the dependency is installed
 */
installed: boolean; 
/**
 * Whether the dependency is authenticated (for tools that require auth)
 */
authenticated: boolean | null; 
/**
 * Username/account if authenticated
 */
auth_user: string | null; 
/**
 * Authentication hint URL if not authenticated
 */
auth_hint_url: string | null; 
/**
 * Version string if installed
 */
version: string | null; 
/**
 * Path to the executable if installed
 */
path: string | null; 
/**
 * Installation instructions if not installed
 */
install_hint: string }
/**
 * Status of all DevOps dependencies
 */
export type DevOpsDependencies = { 
/**
 * GitHub CLI status (required)
 */
gh: DependencyStatus; 
/**
 * tmux status (required)
 */
tmux: DependencyStatus; 
/**
 * Docker status (optional, enables sandboxed agents)
 */
docker: DependencyStatus; 
/**
 * Claude Code CLI status
 */
claude: DependencyStatus; 
/**
 * Aider CLI status
 */
aider: DependencyStatus; 
/**
 * Gemini CLI status (Google AI)
 */
gemini: DependencyStatus; 
/**
 * Ollama status (local LLM server)
 */
ollama: DependencyStatus; 
/**
 * vLLM status (high-performance inference)
 */
vllm: DependencyStatus; 
/**
 * Whether all required dependencies are installed (gh + tmux + at least one agent)
 */
all_satisfied: boolean; 
/**
 * List of available agent types that are installed
 */
available_agents: string[]; 
/**
 * Whether sandboxed (Docker) agents are available
 */
sandbox_available: boolean }
/**
 * Discord state for frontend
 */
export type DiscordState = { connected: boolean; in_voice: boolean; listening: boolean; guild_name: string | null; channel_name: string | null; error: string | null }
/**
 * Embedding model info returned from sidecar
 */
export type EmbeddingModelInfo = { id: string; name: string; description: string; dimension: number; size_mb: number; is_downloaded: boolean; is_loaded: boolean }
export type EngineType = "Whisper" | "Parakeet" | "Moonshine"
/**
 * Configuration for creating a new epic issue
 */
export type EpicConfig = { 
/**
 * Epic title (without [EPIC] prefix - added automatically)
 */
title: string; 
/**
 * Tracking repository where Epic/Sub-issues are created (e.g., "org/Handy")
 */
repo: string; 
/**
 * Work repository where code lives and agents work (e.g., "user/project")
 * If None, defaults to same as repo
 */
work_repo: string | null; 
/**
 * Epic description/goal (1-2 sentences)
 */
goal: string; 
/**
 * Success metrics (checkbox list)
 */
success_metrics: string[]; 
/**
 * Phases with descriptions
 */
phases: PhaseConfig[]; 
/**
 * Labels to add to epic (epic label added automatically)
 */
labels: string[] }
/**
 * Information about a created epic
 */
export type EpicInfo = { 
/**
 * Epic issue number
 */
epic_number: number; 
/**
 * Tracking repository (where Epic is created)
 */
repo: string; 
/**
 * Work repository (where code lives)
 */
work_repo: string; 
/**
 * Epic title
 */
title: string; 
/**
 * GitHub issue URL
 */
url: string; 
/**
 * Phases from config
 */
phases: PhaseConfig[] }
/**
 * Epic progress statistics
 */
export type EpicProgress = { 
/**
 * Total sub-issues
 */
total: number; 
/**
 * Completed sub-issues
 */
completed: number; 
/**
 * Percentage complete
 */
percentage: number; 
/**
 * Remaining sub-issues
 */
remaining: number }
/**
 * Recovery information for an epic
 */
export type EpicRecoveryInfo = { 
/**
 * The epic info
 */
epic: EpicInfo; 
/**
 * Existing sub-issues for this epic
 */
sub_issues: ExistingSubIssue[]; 
/**
 * Progress statistics
 */
progress: EpicProgress; 
/**
 * Phases that have no sub-issues yet
 */
phases_without_issues: number[]; 
/**
 * Sub-issues that are ready for agents (have todo label, not closed)
 */
ready_for_agents: ExistingSubIssue[]; 
/**
 * Sub-issues that have agents actively working
 */
in_progress: ExistingSubIssue[] }
/**
 * Information about an existing sub-issue linked to an epic
 */
export type ExistingSubIssue = { 
/**
 * Issue number
 */
issue_number: number; 
/**
 * Issue title
 */
title: string; 
/**
 * Phase number (extracted from labels)
 */
phase: number | null; 
/**
 * Current state (open/closed)
 */
state: string; 
/**
 * Labels on the issue
 */
labels: string[]; 
/**
 * URL to the issue
 */
url: string; 
/**
 * Whether an agent is currently working on it
 */
has_agent_working: boolean }
/**
 * Output mode for filler word detection
 */
export type FillerOutputMode = 
/**
 * Show coaching feedback only, don't paste anything
 */
"coaching_only" | 
/**
 * Remove filler words and paste cleaned text
 */
"paste_cleaned" | 
/**
 * Paste original text and show coaching feedback
 */
"paste_original" | 
/**
 * Remove filler words, paste cleaned text, and show coaching feedback
 */
"both"
/**
 * GitHub authentication status.
 */
export type GhAuthStatus = { 
/**
 * Whether the user is authenticated
 */
authenticated: boolean; 
/**
 * Username if authenticated
 */
username: string | null; 
/**
 * Scopes available
 */
scopes: string[]; 
/**
 * Error message if not authenticated
 */
error: string | null }
/**
 * A GitHub issue comment.
 */
export type GitHubComment = { 
/**
 * Comment ID
 */
id: number; 
/**
 * Comment body
 */
body: string; 
/**
 * Author username
 */
author: string; 
/**
 * Created timestamp
 */
created_at: string }
/**
 * A GitHub issue.
 */
export type GitHubIssue = { 
/**
 * Issue number
 */
number: number; 
/**
 * Issue title
 */
title: string; 
/**
 * Issue body/description
 */
body: string | null; 
/**
 * Issue state (open, closed)
 */
state: string; 
/**
 * Issue URL
 */
url: string; 
/**
 * Labels on the issue
 */
labels: string[]; 
/**
 * Assignees
 */
assignees: string[]; 
/**
 * Author username
 */
author: string; 
/**
 * Created timestamp
 */
created_at: string; 
/**
 * Updated timestamp
 */
updated_at: string; 
/**
 * Repository in owner/repo format
 */
repo: string }
/**
 * A GitHub Pull Request.
 */
export type GitHubPullRequest = { 
/**
 * PR number
 */
number: number; 
/**
 * PR title
 */
title: string; 
/**
 * PR body/description
 */
body: string | null; 
/**
 * PR state (open, closed, merged)
 */
state: string; 
/**
 * PR URL
 */
url: string; 
/**
 * Source branch
 */
head_branch: string; 
/**
 * Target branch
 */
base_branch: string; 
/**
 * Is the PR a draft
 */
is_draft: boolean; 
/**
 * Is the PR mergeable
 */
mergeable: boolean | null; 
/**
 * Labels on the PR
 */
labels: string[]; 
/**
 * Author username
 */
author: string; 
/**
 * Created timestamp
 */
created_at: string; 
/**
 * Updated timestamp
 */
updated_at: string; 
/**
 * Repository in owner/repo format
 */
repo: string }
export type GuildInfo = { id: string; name: string }
export type HistoryEntry = { id: number; file_name: string; timestamp: number; saved: boolean; title: string; transcription_text: string; post_processed_text: string | null; post_process_prompt: string | null }
/**
 * Agent metadata stored in issue comments.
 */
export type IssueAgentMetadata = { 
/**
 * Session name
 */
session: string; 
/**
 * Machine ID
 */
machine_id: string; 
/**
 * Worktree path
 */
worktree: string | null; 
/**
 * Agent type
 */
agent_type: string; 
/**
 * Started timestamp
 */
started_at: string; 
/**
 * Current status
 */
status: string }
/**
 * Parsed issue with agent metadata.
 */
export type IssueWithAgent = { 
/**
 * The issue
 */
issue: GitHubIssue; 
/**
 * Agent metadata if assigned
 */
agent: IssueAgentMetadata | null }
export type LLMPrompt = { id: string; name: string; prompt: string }
export type LogLevel = "trace" | "debug" | "info" | "warn" | "error"
/**
 * A memory message from the sidecar
 */
export type MemoryMessage = { id: string; user_id: string; content: string; is_bot: boolean; timestamp: number; similarity: number | null }
/**
 * Status information about the memory system
 */
export type MemoryStatus = { is_running: boolean; model_loaded: boolean; total_memories: number }
/**
 * User info with memory count
 */
export type MemoryUserInfo = { user_id: string; memory_count: number }
export type ModelInfo = { id: string; name: string; description: string; filename: string; url: string | null; size_mb: number; is_downloaded: boolean; is_downloading: boolean; partial_size: number; is_directory: boolean; engine_type: EngineType; accuracy_score: number; speed_score: number }
export type ModelLoadStatus = { is_loaded: boolean; current_model: string | null }
export type ModelUnloadTimeout = "never" | "immediately" | "min_2" | "min_5" | "min_10" | "min_15" | "hour_1" | "sec_5"
/**
 * Mode for Onichan LLM processing
 */
export type OnichanMode = "Cloud" | "Local"
/**
 * Information about an Onichan model (LLM or TTS)
 */
export type OnichanModelInfo = { id: string; name: string; description: string; filename: string; url: string | null; size_mb: number; is_downloaded: boolean; is_downloading: boolean; partial_size: number; model_type: OnichanModelType; 
/**
 * For LLM models: context size
 */
context_size: number | null; 
/**
 * For TTS models: sample rate
 */
sample_rate: number | null; 
/**
 * For TTS models: voice name/style
 */
voice_name: string | null }
/**
 * Type of Onichan model
 */
export type OnichanModelType = "Llm" | "Tts"
/**
 * Result of starting orchestration for an epic
 */
export type OrchestrationResult = { 
/**
 * Epic number
 */
epic_number: number; 
/**
 * Created sub-issues
 */
sub_issues: SubIssueInfo[]; 
/**
 * Spawned agents (for agent-assisted phases)
 */
spawned_agents: SpawnedAgentInfo[]; 
/**
 * Phases that were started
 */
started_phases: number[]; 
/**
 * Any warnings during orchestration
 */
warnings: string[] }
export type OverlayPosition = "none" | "top" | "bottom"
export type PasteMethod = "ctrl_v" | "direct" | "none" | "shift_insert" | "ctrl_shift_v"
/**
 * Phase configuration within an epic
 */
export type PhaseConfig = { 
/**
 * Phase name (e.g., "Foundation", "Integration Tests")
 */
name: string; 
/**
 * Phase description
 */
description: string; 
/**
 * Approach: "manual", "agent-assisted", or "automated"
 */
approach: string; 
/**
 * Key tasks for this phase (each becomes a sub-issue)
 */
tasks?: string[]; 
/**
 * Files to modify (optional context for agents)
 */
files?: string[]; 
/**
 * Dependencies - names of phases that must complete first
 */
dependencies?: string[] }
/**
 * Get phase status for an epic (how many sub-issues complete per phase)
 */
export type PhaseStatus = { phase_number: number; phase_name: string; approach: string; total_issues: number; completed_issues: number; in_progress_issues: number; status: string }
/**
 * A pipeline item linking issue -> session -> worktree -> PR.
 * 
 * This struct tracks the full lifecycle of an agent's work on an issue.
 */
export type PipelineItem = { 
/**
 * Unique identifier for this pipeline item
 */
id: string; 
/**
 * Repository in owner/repo format (tracking repo where issue exists)
 */
tracking_repo: string; 
/**
 * Repository where work is done (may be different from tracking_repo)
 */
work_repo: string; 
/**
 * Issue number being worked on
 */
issue_number: number; 
/**
 * Issue title
 */
issue_title: string; 
/**
 * Issue URL
 */
issue_url: string; 
/**
 * Agent type (e.g., "claude", "aider")
 */
agent_type: string; 
/**
 * tmux session name (if active)
 */
session_name: string | null; 
/**
 * Worktree path (if created)
 */
worktree_path: string | null; 
/**
 * Branch name for the work
 */
branch_name: string | null; 
/**
 * Machine ID where agent is running
 */
machine_id: string | null; 
/**
 * PR number (if created)
 */
pr_number: number | null; 
/**
 * PR URL (if created)
 */
pr_url: string | null; 
/**
 * Current PR status
 */
pr_status: PrPipelineStatus; 
/**
 * Overall pipeline status
 */
status: PipelineStatus; 
/**
 * When the item was created/queued
 */
created_at: string; 
/**
 * When work started (agent assigned)
 */
started_at: string | null; 
/**
 * When work completed (PR merged or skipped)
 */
completed_at: string | null; 
/**
 * Any error message if failed
 */
error: string | null }
/**
 * Status of a pipeline item.
 */
export type PipelineStatus = 
/**
 * Issue is queued but not assigned
 */
"queued" | 
/**
 * Issue is assigned to an agent and work is in progress
 */
"in_progress" | 
/**
 * Agent has completed work and PR is pending
 */
"pr_pending" | 
/**
 * PR has been created and is being reviewed
 */
"pr_review" | 
/**
 * PR has been merged, work is complete
 */
"completed" | 
/**
 * Issue was skipped
 */
"skipped" | 
/**
 * Work failed or was abandoned
 */
"failed"
/**
 * Summary of pipeline items for display.
 */
export type PipelineSummary = { 
/**
 * Total items in pipeline
 */
total: number; 
/**
 * Items queued (not started)
 */
queued: number; 
/**
 * Items in progress
 */
in_progress: number; 
/**
 * Items with PRs pending review
 */
pr_pending: number; 
/**
 * Completed items
 */
completed: number; 
/**
 * Skipped items
 */
skipped: number; 
/**
 * Failed items
 */
failed: number }
/**
 * Configuration for planning an Epic from a markdown file
 */
export type PlanFromMarkdownConfig = { 
/**
 * Path to the markdown plan file
 */
plan_file_path: string; 
/**
 * Tracking repository where Epic/Sub-issues are created (e.g., "KBVE/Handy")
 */
repo: string; 
/**
 * Work repository where code lives and agents work (e.g., "user/project")
 * If None, defaults to same as repo
 */
work_repo: string | null; 
/**
 * Optional: Override epic title
 */
title_override: string | null; 
/**
 * Optional: Agent to use for planning (default: claude)
 */
planning_agent: string | null }
/**
 * Result of the planning operation
 */
export type PlanResult = { 
/**
 * Created Epic info
 */
epic: EpicInfo; 
/**
 * Created sub-issues
 */
sub_issues: SubIssueInfo[]; 
/**
 * Agent used for planning
 */
planning_agent: string; 
/**
 * Summary of what was created
 */
summary: string }
/**
 * Parsed plan template ready for use
 */
export type PlanTemplate = { 
/**
 * Template identifier (filename without extension)
 */
id: string; 
/**
 * Template title from frontmatter
 */
title: string; 
/**
 * Template description from frontmatter
 */
description: string; 
/**
 * Labels from frontmatter
 */
labels: string[]; 
/**
 * Repository for tracking issues (e.g., "KBVE/KBVE")
 */
tracking_repo: string | null; 
/**
 * Repository for working/implementation (e.g., "KBVE/Handy")
 */
working_repo: string | null; 
/**
 * Epic goal extracted from markdown
 */
goal: string; 
/**
 * Success metrics extracted from markdown
 */
success_metrics: string[]; 
/**
 * Phases extracted from markdown
 */
phases: PhaseConfig[] }
export type PostProcessProvider = { id: string; label: string; base_url: string; allow_base_url_edit?: boolean; models_endpoint?: string | null }
/**
 * PR check status.
 */
export type PrCheckStatus = { 
/**
 * Overall status (pending, success, failure)
 */
state: string; 
/**
 * Number of passing checks
 */
passing: number; 
/**
 * Number of failing checks
 */
failing: number; 
/**
 * Number of pending checks
 */
pending: number; 
/**
 * Total number of checks
 */
total: number }
/**
 * Status of a PR in the pipeline.
 */
export type PrPipelineStatus = 
/**
 * No PR has been created yet
 */
"none" | 
/**
 * PR is in draft state
 */
"draft" | 
/**
 * PR is ready for review
 */
"ready" | 
/**
 * PR needs review (has reviewers assigned)
 */
"needs_review" | 
/**
 * PR has been approved
 */
"approved" | 
/**
 * PR has been merged
 */
"merged" | 
/**
 * PR was closed without merging
 */
"closed"
/**
 * PR review status.
 */
export type PrReviewStatus = { 
/**
 * Number of approvals
 */
approved: number; 
/**
 * Number of changes requested
 */
changes_requested: number; 
/**
 * Number of reviews pending
 */
pending: number }
/**
 * Full PR status including checks and reviews.
 */
export type PrStatus = { 
/**
 * The PR
 */
pr: GitHubPullRequest; 
/**
 * Check status
 */
checks: PrCheckStatus; 
/**
 * Review status
 */
reviews: PrReviewStatus }
export type RecordingRetentionPeriod = "never" | "preserve_limit" | "days_3" | "weeks_2" | "months_3"
/**
 * A session recovered during startup
 */
export type RecoveredSession = { metadata: AgentMetadata; source: RecoverySource; tmux_alive: boolean; worktree_exists: boolean; recommended_action: RecoveryAction }
/**
 * Recommended action for a recovered session
 */
export type RecoveryAction = 
/**
 * tmux alive, continue monitoring
 */
"Resume" | 
/**
 * tmux dead but work incomplete, offer restart
 */
"Restart" | 
/**
 * orphan session, offer to kill/remove
 */
"Cleanup" | 
/**
 * completed normally, nothing to do
 */
"None"
/**
 * Result of attempting to recover/restart sessions
 */
export type RecoveryResult = { 
/**
 * Session name
 */
session: string; 
/**
 * Whether recovery was successful
 */
success: boolean; 
/**
 * Action that was taken
 */
action: RecoveryAction; 
/**
 * Error message if recovery failed
 */
error: string | null }
/**
 * Source of recovered session information
 */
export type RecoverySource = 
/**
 * Found in tmux, normal operation
 */
"Tmux" | 
/**
 * Recovered from GitHub issue comment
 */
"GitHubIssue" | 
/**
 * Confirmed by both sources
 */
"Both"
/**
 * Configuration for spawning a sandboxed agent container
 */
export type SandboxConfig = { 
/**
 * Sandbox mode - DevContainer (recommended) or DirectDocker
 */
mode: SandboxMode; 
/**
 * Docker image to use (for DirectDocker mode)
 */
image: string | null; 
/**
 * Working directory to mount (the worktree path)
 */
workdir: string; 
/**
 * GitHub token for API access (passed as env var)
 */
gh_token: string | null; 
/**
 * Anthropic API key for Claude (passed as env var)
 */
anthropic_api_key: string | null; 
/**
 * Issue reference (org/repo#number)
 */
issue_ref: string; 
/**
 * Agent type (claude, aider, etc.)
 */
agent_type: string; 
/**
 * Whether to auto-accept all operations (safe in sandbox)
 */
auto_accept: boolean; 
/**
 * Memory limit (e.g., "4g")
 */
memory_limit: string | null; 
/**
 * CPU limit (e.g., "2")
 */
cpu_limit: string | null; 
/**
 * Network mode: "bridge" (default), "none" (air-gapped), or "host"
 */
network_mode: string | null }
/**
 * Sandbox mode - how to run the isolated agent
 */
export type SandboxMode = 
/**
 * Use Dev Container (recommended) - creates .devcontainer/devcontainer.json
 * and uses the official Anthropic devcontainer feature
 */
"DevContainer" | 
/**
 * Use direct Docker container (simpler but less integrated)
 */
"DirectDocker"
/**
 * Result of spawning a sandboxed container
 */
export type SandboxResult = { 
/**
 * Container ID
 */
container_id: string; 
/**
 * Container name
 */
container_name: string; 
/**
 * Whether the container started successfully
 */
started: boolean }
/**
 * Status of a running sandbox container
 */
export type SandboxStatus = { 
/**
 * Container ID
 */
container_id: string; 
/**
 * Container name
 */
container_name: string; 
/**
 * Whether container is running
 */
running: boolean; 
/**
 * Exit code if stopped
 */
exit_code: number | null; 
/**
 * Container status string
 */
status: string }
/**
 * Status of an agent session
 */
export type SessionStatus = 
/**
 * Session is running and agent is active
 */
"Running" | 
/**
 * Session exists but agent process has exited
 */
"Stopped" | 
/**
 * Session was recovered from metadata (tmux or GitHub)
 */
"Recovered"
export type ShortcutBinding = { id: string; name: string; description: string; default_binding: string; current_binding: string }
/**
 * Configuration for skipping an issue.
 */
export type SkipIssueConfig = { 
/**
 * Repository where the issue exists
 */
repo: string; 
/**
 * Issue number to skip
 */
issue_number: number; 
/**
 * Optional reason for skipping
 */
reason: string | null; 
/**
 * Labels to add (defaults to "agent-skipped")
 */
add_labels?: string[]; 
/**
 * Labels to remove (defaults to "agent-todo")
 */
remove_labels?: string[] }
export type SoundTheme = "marimba" | "pop" | "custom"
/**
 * Configuration for spawning an agent from a GitHub issue
 */
export type SpawnAgentConfig = { 
/**
 * Issue reference (e.g., "org/Handy#101")
 */
issue_ref: string; 
/**
 * Override agent type (if not specified in issue body)
 */
agent_type: string | null; 
/**
 * Custom session name (if not auto-generated)
 */
session_name: string | null; 
/**
 * Work repository (where code lives and agent works)
 * If None, extracts from issue body or uses issue_ref repo
 */
work_repo: string | null }
/**
 * Result of spawning an agent.
 */
export type SpawnResult = { 
/**
 * The issue being worked on
 */
issue: GitHubIssue; 
/**
 * The created worktree
 */
worktree: WorktreeCreateResult; 
/**
 * The tmux session name
 */
session_name: string; 
/**
 * Machine ID where agent is running
 */
machine_id: string }
/**
 * Information about a spawned agent
 */
export type SpawnedAgentInfo = { 
/**
 * Issue number the agent is working on
 */
issue_number: number; 
/**
 * Session name (tmux)
 */
session_name: string; 
/**
 * Worktree path
 */
worktree_path: string; 
/**
 * Agent type (claude, aider, etc.)
 */
agent_type: string }
/**
 * Configuration for starting orchestration
 */
export type StartOrchestrationConfig = { 
/**
 * Which phases to start (1-indexed). If empty, starts Phase 1.
 */
phases: number[]; 
/**
 * Whether to auto-spawn agents for agent-assisted phases
 */
auto_spawn_agents: boolean; 
/**
 * Default agent type for spawning
 */
default_agent_type: string; 
/**
 * Local filesystem path to git repository for creating worktrees.
 * Must be a valid git repository path (e.g., "/Users/me/projects/MyRepo").
 * If empty or invalid, agent spawning will be skipped but issues will still be created.
 */
worktree_base: string }
/**
 * Configuration for creating a sub-issue
 */
export type SubIssueConfig = { 
/**
 * Sub-issue title (e.g., "Implement test_agent_spawning.rs")
 */
title: string; 
/**
 * Phase number (1-indexed)
 */
phase: number; 
/**
 * Estimated time (e.g., "6 hours", "2 days")
 */
estimated_time: string; 
/**
 * Dependencies (other sub-issue titles or "None")
 */
dependencies: string; 
/**
 * Goal description (1-2 sentences)
 */
goal: string; 
/**
 * Detailed task breakdown (markdown)
 */
tasks: string; 
/**
 * Acceptance criteria (checkbox list)
 */
acceptance_criteria: string[]; 
/**
 * Recommended agent type
 */
agent_type: string; 
/**
 * Work repository (where agent will work)
 * If None, inherits from Epic
 */
work_repo: string | null }
/**
 * Information about a created sub-issue
 */
export type SubIssueInfo = { 
/**
 * Issue number
 */
issue_number: number; 
/**
 * Issue title
 */
title: string; 
/**
 * Phase number
 */
phase: number; 
/**
 * Recommended agent type
 */
agent_type: string; 
/**
 * Work repository (where agent will work)
 */
work_repo: string; 
/**
 * GitHub issue URL
 */
url: string }
export type SupabaseSession = { access_token: string; refresh_token: string; expires_at: number; user_id: string; email: string | null; 
/**
 * User's display name from OAuth provider
 */
name: string | null; 
/**
 * User's avatar URL from OAuth provider
 */
avatar_url: string | null; 
/**
 * OAuth provider used (github, discord, twitch)
 */
provider: string | null }
/**
 * Information about a tmux session
 */
export type TmuxSession = { 
/**
 * Session name
 */
name: string; 
/**
 * Whether the session is attached
 */
attached: boolean; 
/**
 * Number of windows in the session
 */
windows: number; 
/**
 * Session creation time (Unix timestamp)
 */
created: number; 
/**
 * Agent metadata if this is a Handy session
 */
metadata: AgentMetadata | null; 
/**
 * Current status
 */
status: SessionStatus }
/**
 * Tracked state for a phase
 */
export type TrackedPhase = { 
/**
 * Phase number (1-indexed)
 */
phase_number: number; 
/**
 * Phase name
 */
name: string; 
/**
 * Phase status
 */
status: TrackedPhaseStatus; 
/**
 * Sub-issue numbers assigned to this phase
 */
sub_issues: number[]; 
/**
 * Count of completed sub-issues
 */
completed_count: number; 
/**
 * Total sub-issues for this phase
 */
total_count: number }
/**
 * Status of a phase within an Epic (for persisted tracking)
 */
export type TrackedPhaseStatus = 
/**
 * Phase not started
 */
"not_started" | 
/**
 * Phase is in progress
 */
"in_progress" | 
/**
 * Phase is completed
 */
"completed" | 
/**
 * Phase was skipped
 */
"skipped"
/**
 * Tracked state for a sub-issue
 */
export type TrackedSubIssue = { 
/**
 * Issue number
 */
issue_number: number; 
/**
 * Issue title
 */
title: string; 
/**
 * Phase number this belongs to
 */
phase: number | null; 
/**
 * Current state (open/closed)
 */
state: string; 
/**
 * Agent type assigned
 */
agent_type: string | null; 
/**
 * Session name if agent is working
 */
session_name: string | null; 
/**
 * Whether an agent is currently working
 */
has_agent_working: boolean; 
/**
 * URL to the issue
 */
url: string }
/**
 * Result of a worktree creation attempt.
 */
export type WorktreeCreateResult = { 
/**
 * Path to the created worktree
 */
path: string; 
/**
 * Branch name
 */
branch: string; 
/**
 * Whether a new branch was created
 */
branch_created: boolean }
/**
 * Information about a git worktree.
 */
export type WorktreeInfo = { 
/**
 * Absolute path to the worktree
 */
path: string; 
/**
 * Branch name checked out in this worktree
 */
branch: string | null; 
/**
 * Commit SHA of HEAD
 */
head: string; 
/**
 * Whether this is the main worktree
 */
is_main: boolean; 
/**
 * Whether the worktree is locked
 */
is_locked: boolean; 
/**
 * Whether the worktree is prunable (missing)
 */
is_prunable: boolean }

/** tauri-specta globals **/

import {
	invoke as TAURI_INVOKE,
	Channel as TAURI_CHANNEL,
} from "@tauri-apps/api/core";
import * as TAURI_API_EVENT from "@tauri-apps/api/event";
import { type WebviewWindow as __WebviewWindow__ } from "@tauri-apps/api/webviewWindow";

type __EventObj__<T> = {
	listen: (
		cb: TAURI_API_EVENT.EventCallback<T>,
	) => ReturnType<typeof TAURI_API_EVENT.listen<T>>;
	once: (
		cb: TAURI_API_EVENT.EventCallback<T>,
	) => ReturnType<typeof TAURI_API_EVENT.once<T>>;
	emit: null extends T
		? (payload?: T) => ReturnType<typeof TAURI_API_EVENT.emit>
		: (payload: T) => ReturnType<typeof TAURI_API_EVENT.emit>;
};

export type Result<T, E> =
	| { status: "ok"; data: T }
	| { status: "error"; error: E };

function __makeEvents__<T extends Record<string, any>>(
	mappings: Record<keyof T, string>,
) {
	return new Proxy(
		{} as unknown as {
			[K in keyof T]: __EventObj__<T[K]> & {
				(handle: __WebviewWindow__): __EventObj__<T[K]>;
			};
		},
		{
			get: (_, event) => {
				const name = mappings[event as keyof T];

				return new Proxy((() => {}) as any, {
					apply: (_, __, [window]: [__WebviewWindow__]) => ({
						listen: (arg: any) => window.listen(name, arg),
						once: (arg: any) => window.once(name, arg),
						emit: (arg: any) => window.emit(name, arg),
					}),
					get: (_, command: keyof __EventObj__<any>) => {
						switch (command) {
							case "listen":
								return (arg: any) => TAURI_API_EVENT.listen(name, arg);
							case "once":
								return (arg: any) => TAURI_API_EVENT.once(name, arg);
							case "emit":
								return (arg: any) => TAURI_API_EVENT.emit(name, arg);
						}
					},
				});
			},
		},
	);
}
